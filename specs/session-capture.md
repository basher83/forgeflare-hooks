# Session Transcript Persistence Specification

**Status:** Active
**Target:** Persist conversation transcripts to disk in Entire-compatible JSONL format for post-session observability

---

## Why

Forgeflare runs as a standalone agent outside Claude Code. No hooks fire, no session capture tool observes it. When a Ralph loop iteration finishes, the conversation — tool calls, reasoning, errors, decisions — evaporates. The only surviving artifact is the git diff. This makes debugging convergence failures, auditing agent behavior, and understanding why the agent made specific decisions impossible without re-running the session.

Entire.io captures Claude Code sessions via hooks into a well-defined JSONL format stored on shadow git branches. Forgeflare can emit the same format directly — it already holds the conversation in memory as `Vec<Message>` with full tool_use/tool_result content blocks. The missing pieces are timestamps, session identity, and token usage from API responses.

---

## Requirements

**R1. JSONL Transcript**
- Write one JSON object per line to `.entire/metadata/{session-id}/full.jsonl`
- Each line represents one conversation turn (user prompt or assistant response)
- User turns: `type: "user"`, `message.role: "user"`, `message.content` (text string or tool_result array)
- Assistant turns: `type: "assistant"`, `message.role: "assistant"`, `message.content` (text or tool_use array)
- Every line includes: `sessionId`, `uuid` (unique per line), `parentUuid` (previous line's uuid), `timestamp` (ISO 8601), `cwd`, `version` (forgeflare version)
- First line has `parentUuid: null`

**R2. Token Usage**
- Parse `usage` from Anthropic API `message_start` and `message_delta` SSE events
- Fields: `input_tokens`, `output_tokens`, `cache_creation_input_tokens`, `cache_read_input_tokens`
- Attach usage to assistant turn lines in JSONL as `message.usage`
- Return usage from `send_message()` alongside the existing `(Vec<ContentBlock>, StopReason)` tuple

**R3. Session Identity**
- Generate a session ID at startup: `{date}-{uuid}` format (e.g., `2026-02-10-a1b2c3d4-e5f6-7890-abcd-ef1234567890`)
- Use UUID v4 for uniqueness
- Session ID determines the output directory path

**R4. Timestamps**
- Record wall-clock time (UTC, ISO 8601) for every conversation turn
- Timestamp captures when the turn was added to the conversation, not when it was displayed

**R5. Supporting Files**
- `.entire/metadata/{session-id}/prompt.txt` — the initial user prompt (first non-empty user input, or piped stdin content)
- `.entire/metadata/{session-id}/summary.txt` — not generated by forgeflare; left empty or absent (summary generation is a separate concern)
- `.entire/metadata/{session-id}/context.md` — session metadata header (session ID, model, start time) followed by a "Key Actions" list extracted from tool_use blocks (tool name + first argument)

**R6. Write Timing**
- Append to `full.jsonl` after each complete turn (user prompt committed, or assistant response fully received and tools dispatched)
- Do not buffer the entire session and write at exit — if forgeflare crashes or is killed, partial transcripts survive
- Write `prompt.txt` on first user input (the data is available immediately; waiting until session end loses it on crash — the exact failure mode this spec exists to observe)
- Write `context.md` at session end (requires full session history to extract key actions)

**R7. Directory Structure**
- Create `.entire/metadata/{session-id}/` on first write
- Create `.entire/` and `.entire/metadata/` if they don't exist
- Respect existing `.entire/` directory (don't overwrite settings.json or other Entire state)

---

## Architecture

```yaml
Conversation loop (main.rs)
  │
  ├─ on user input ──→ append user turn to full.jsonl
  │
  ├─ send_message() ──→ returns (blocks, stop_reason, usage)
  │                                                  ↑ NEW
  │
  ├─ on assistant response ──→ append assistant turn to full.jsonl
  │
  ├─ on first user input ──→ write prompt.txt
  └─ on session end ──→ write context.md

Output:
  .entire/metadata/{session-id}/
  ├── full.jsonl       # One JSON object per line, append-only
  ├── prompt.txt       # First user prompt
  └── context.md       # Session metadata + key actions
```

Changes to existing code:

1. `api.rs` — parse `usage` from SSE events, return as third element from `send_message()`
2. `main.rs` — generate session ID at startup, append JSONL after each turn, write `prompt.txt` on first user input, write `context.md` at exit
3. New: session transcript module (struct definitions, JSONL serialization, file I/O)
4. `Cargo.toml` — add `uuid` crate (v4 feature) and `chrono` (or use `std::time` with manual formatting)

---

## JSONL Line Format

User turn:

```json
{"type":"user","sessionId":"2026-02-10-uuid","uuid":"turn-uuid","parentUuid":"prev-uuid","timestamp":"2026-02-10T23:31:00Z","cwd":"/path/to/project","version":"0.0.44","message":{"role":"user","content":"explain main.rs"}}
```

Assistant turn with tool use:

```json
{"type":"assistant","sessionId":"2026-02-10-uuid","uuid":"turn-uuid","parentUuid":"prev-uuid","timestamp":"2026-02-10T23:31:05Z","cwd":"/path/to/project","version":"0.0.44","message":{"role":"assistant","content":[{"type":"text","text":"Let me read that file."},{"type":"tool_use","id":"toolu_01X","name":"read_file","input":{"path":"src/main.rs"}}],"usage":{"input_tokens":1200,"output_tokens":350,"cache_creation_input_tokens":0,"cache_read_input_tokens":800}}}
```

Tool result (part of next user turn):

```json
{"type":"user","sessionId":"2026-02-10-uuid","uuid":"turn-uuid","parentUuid":"prev-uuid","timestamp":"2026-02-10T23:31:06Z","cwd":"/path/to/project","version":"0.0.44","message":{"role":"user","content":[{"type":"tool_result","tool_use_id":"toolu_01X","content":"1: use std::io;\n2: ..."}]}}
```

---

## Success Criteria

- [ ] JSONL file written incrementally (survives mid-session crash)
- [ ] Token usage parsed from API SSE stream and attached to assistant turns
- [ ] Session ID generated with date-uuid format
- [ ] Timestamps on every turn (UTC ISO 8601)
- [ ] prompt.txt written on first user input (survives mid-session crash)
- [ ] context.md contains session metadata and key actions list
- [ ] Existing `.entire/` state (settings.json) not modified
- [ ] No performance regression in conversation loop (file append is fast)
- [ ] JSONL readable by `jq` line-by-line (valid JSON per line)

---

## Non-Goals

- Shadow branch storage (Entire's git plumbing — forgeflare writes to filesystem only)
- Checkpoint linking via git trailers (requires git hook integration)
- Session summarization (would require a second API call)
- Rewind or resume from transcripts (read-only capture, not bidirectional)
- Entire CLI interop beyond format compatibility (no `entire status` awareness)
- Structured patches in tool results (Entire extracts these from edit diffs; forgeflare stores raw tool output)
- Compression or rotation of old transcripts
- Telemetry or analytics

---

## Implementation Notes

- The `Message` struct already derives `Serialize`. The JSONL line is a wrapper struct containing session metadata fields plus the existing `Message` as a nested field. Minimal new serialization code.
- `StopReason` needs `Serialize` added to its derive list (currently `Debug, Clone, PartialEq` only).
- Token usage lives in two SSE events: `message_start` has `usage.input_tokens` and `usage.cache_creation_input_tokens`; `message_delta` has `usage.output_tokens`. The parser already processes these events for content — adding usage extraction is a field-level change, not an architectural change.
- UUID v4 generation: `uuid` crate with `v4` feature. Single dependency add. Alternatively, read 16 random bytes and format as hex — avoids the dependency but loses RFC 4122 compliance.
- File append: `OpenOptions::new().create(true).append(true).open(path)` per write. No file handle kept open across the session — simpler, handles crashes, negligible performance cost at conversation-turn granularity.
- The `.entire/metadata/` path is hardcoded relative to cwd. This matches Entire's behavior (session data lives in the project directory).
- context.md key actions list: iterate tool_use blocks in conversation, emit `- **{tool_name}**: {first_arg_value}` per tool call. This matches Entire's observed format.
- Version string: read from `env!("CARGO_PKG_VERSION")` at compile time. Already available, no new plumbing.
